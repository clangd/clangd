'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.graphqlEndpoint = undefined;

let getLastSuccessfulCommit = (() => {
  var _ref = _asyncToGenerator(function* ({ owner, name, token, after } = {}) {
    if (!owner) {
      throw new Error('"owner" needs to be defined');
    }
    if (!name) {
      throw new Error('"name" needs to be defined');
    }
    if (!token) {
      throw new Error('"token" needs to be defined');
    }

    const response = yield getCommitsInfo({ owner, name, token, after });
    const parsed = parseResponse(response);

    if (parsed.commit) {
      return parsed.commit;
    }

    if (parsed.after) {
      return getLastSuccessfulCommit({ owner, name, token, after: parsed.after });
    }

    return null;
  });

  return function getLastSuccessfulCommit() {
    return _ref.apply(this, arguments);
  };
})();

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

exports.default = getLastSuccessfulCommit;
const graphqlEndpoint = exports.graphqlEndpoint = 'https://api.github.com/graphql';

function getCommitsInfo({ owner, name, token, after = null }) {
  return _axios2.default.post(graphqlEndpoint, {
    query: createQuery(owner, name, after)
  }, {
    headers: {
      Authorization: `Bearer ${token}`
    }
  });
}

function createQuery(owner, name, after) {
  const query = `
    query {
      repository(owner: "${owner}", name: "${name}") {
        ref(qualifiedName: "master") {
          target {
            ... on Commit {
              history(first: 10${after ? `, after: "${after}"` : ''}) {
                pageInfo {
                  hasNextPage
                  endCursor
                }
                edges {
                  node {
                    status {
                      state
                    }
                    message
                    oid
                  }
                }
              }
            }
          }
        }
      }
    }
  `;

  return query;
}

function parseResponse(response) {
  const history = response.data.data.repository.ref.target.history;
  const hasNextPage = history.pageInfo.hasNextPage;
  const after = history.pageInfo.endCursor;
  const commit = findSuccessCommit(history.edges);

  if (commit) {
    return { commit, after: null };
  }

  if (hasNextPage && after) {
    return { commit: null, after };
  }

  return { commit: null, after: null };
}

function findSuccessCommit(edges) {
  // eslint-disable-next-line no-restricted-syntax
  for (const commit of edges) {
    if (commit.node.status && commit.node.status.state === 'SUCCESS') {
      return commit;
    }
  }

  return null;
}
//# sourceMappingURL=index.js.map